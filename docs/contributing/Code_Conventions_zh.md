## DNAnalyzer 代码规范

在为 DNAnalyzer 贡献代码时，您应始终牢记这些实践。

### 源文件名

- 源文件名包含其所包含的顶级类的大小写敏感名称，加上 .java 扩展名。

### 源文件结构

- 源文件按顺序包括：
    - 许可证或版权信息（如果存在）
    - 包声明
    - 导入声明
    - 恰好一个顶级类

- 每个存在的部分之间用一个空行分隔。
- 所有“特殊变量”（即需要尽早初始化的常量）在文件顶部、任何导入语句下方声明。

### 导入

- 不使用通配符导入，无论是静态的还是其他的。
- 导入语句不换行。

- 导入顺序如下：
    - 所有静态导入在一个单独的块中。
    - 所有非静态导入在一个单独的块中。
    - 如果同时存在静态和非静态导入，则用一个空行分隔这两个块。导入语句之间没有其他空行。
    - 静态导入不用于静态嵌套类。它们使用普通导入方式导入。

### 类声明

- 每个顶级类都驻留在其自己的源文件中。
- 类中名称相同的方法出现在一个连续的组中，中间没有其他成员。这也适用于多个构造函数（它们总是具有相同的名称）。即使方法之间的修饰符（如 static 或 private）不同，此规则也适用。

### 格式化

- 大括号
    - `if`, `else`, `for`, `do` 和 `while` 语句使用大括号，即使主体为空或仅包含单个语句。
    - 开大括号前不换行，除非下面详述。
    - 开大括号后换行。
    - 闭大括号前换行。
    - 闭大括号后换行，仅当该大括号终止一条语句或终止方法、构造函数或命名类的主体时。例如，如果大括号后跟 `else` 或逗号，则其后不换行。
    - 空块或类块结构可以在打开后立即关闭，中间没有任何字符或换行符 (`{}`)。

- 块缩进
    - 每次打开新的块或类块结构时，缩进增加两个空格。当块结束时，缩进返回到先前的缩进级别。缩进级别适用于整个块中的代码和注释。

- 空白
    - 缩进应为4个空格，不使用制表符。
        - [在vscode中进行此设置](https://stackoverflow.com/a/38556923)

- 注释
    - 注释绝不能与已有代码的行在同一行。
    - 使注释简洁，并且只针对重要的代码功能；例如 `// 连接到数据库` 可以，但 `// 打印到控制台` 不行。
    - 如果您不需要代码，请删除它，不要注释掉它。

### 命名

- 包名
    - 包名仅使用小写字母和数字（无下划线）。连续的单词简单地连接在一起。例如，`com.example.deepspace`，而不是 `com.example.deepSpace` 或 `com.example.deep_space`。

- 类名
    - 类名以 `UpperCamelCase`（大驼峰命名法）编写。
    - 类名通常是名词或名词短语。例如，`Character` 或 `ImmutableList`。接口名称也可以是名词或名词短语（例如 `List`），但有时也可以是形容词或形容词短语（例如 `Readable`）。

- 方法名
    - 方法名以 `lowerCamelCase`（小驼峰命名法）编写。
    - 方法名通常是动词或动词短语。例如，`sendMessage` 或 `stop`。

- 常量名
    - 常量名使用 `UPPER_SNAKE_CASE`（全大写下划线命名法）：所有字母大写，每个单词与下一个单词之间用单个下划线分隔。

- 非常量字段名
    - 非常量字段名（静态或其他）以 `lowerCamelCase`（小驼峰命名法）编写。这些名称通常是名词或名词短语。例如，`computedValues` 或 `index`。

- 局部变量名
    - 局部变量名以 `lowerCamelCase`（小驼峰命名法）编写。
    - 即使是 `final` 且不可变的，局部变量也不被视为常量，不应按常量的样式命名。

- 使名称具有代表性，除非显而易见，否则不要使用缩写；即 "authentication"="auth" 可以，但 "question"="antsy" 不行；应重命名灰色区域的名称，如 "Question"="Ques"（即使用 "Question"，而不是 "Ques"）。

### 最佳实践

- 始终使用 `@Override`
    - 只要合法，方法就应标记为 `@Override` 注解。这包括类方法覆盖超类方法、类方法实现接口方法以及接口方法重新指定超接口方法。
- 不忽略捕获的异常
    - 对捕获的异常不执行任何操作的情况非常罕见。（典型的响应是记录它，或者如果认为“不可能”发生，则将其重新抛出为 `AssertionError`。）
- 尽可能重用代码（即，如果某事在多个地方完成，看看是否可以创建一个函数）
- 如果您看到更好的方法来完成相同的任务，请使算法更优雅
- 拆分庞大的函数；每个函数只应执行一项任务

最后一件事：如果您要重构大量代码，请记住告知团队其他成员，以便我们能够协调并避免冲突！
